import { app, BrowserWindow, dialog, ipcMain, Menu, net, protocol, session } from "electron";
import { ensureDirectory, listFiles, move, undo } from "./fstools";
import { sep } from "node:path";
import { Commands, fetchTimeout, MoveResult } from "./common";
import contextMenu from "electron-context-menu";

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  app.quit();
}

protocol.registerSchemesAsPrivileged([
  {
    scheme: "media",
    privileges: {
      secure: true,
      supportFetchAPI: true,
      bypassCSP: true,
      stream: true,
    },
  },
]);

contextMenu({
  showCopyImage: true,
  showInspectElement: true,
});

let sourceDirectory = "";
let destinationDirectory = "";

const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });
  mainWindow.maximize();

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  ipcMain.handle(Commands.GetPath, async (event, id, title) => {
    const openResult = await dialog.showOpenDialog(mainWindow, {
      title: title,
      properties: ["openDirectory"],
    });
    return openResult.filePaths.length === 1 ? openResult.filePaths[0] : undefined;
  });

  ipcMain.handle(Commands.Start, async (event, source: string, destination: string, categoryNames: string[]) => {
    sourceDirectory = source;
    destinationDirectory = destination;

    for (const categoryName of categoryNames) {
      ensureDirectory(destinationDirectory, categoryName);
    }

    const files = await listFiles(source);
    return files;
  });

  ipcMain.handle(Commands.Move, async (event, fileName: string, categoryName: string) => {
    try {
      // An extremely ugly yet effective way to make it possible to move videos, especially on Windows.
      await session.defaultSession.closeAllConnections();

      await move(fileName, sourceDirectory, destinationDirectory, categoryName);
      return { success: true, error: undefined } as MoveResult;
    } catch (e) {
      return { success: false, error: e } as MoveResult;
    }
  });

  ipcMain.handle(Commands.Undo, async (event, fileName: string, categoryName: string) => {
    try {
      await undo(fileName, sourceDirectory, destinationDirectory, categoryName);
      return { success: true, error: undefined } as MoveResult;
    } catch (e) {
      return { success: false, error: e } as MoveResult;
    }
  });

  protocol.handle("media", (req) => {
    const mediaPath = req.url.replace(/^media:\/\/src\//, "");
    const fileUrl = `file://${sourceDirectory}${sep}${mediaPath}`;
    console.log(`Fetching ${fileUrl}`);
    return net.fetch(fileUrl, { method: req.method, headers: req.headers, signal: fetchTimeout() });
  });
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on("ready", createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
  }
});

app.on("activate", () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// We don't need a top-level menu.
Menu.setApplicationMenu(null);
